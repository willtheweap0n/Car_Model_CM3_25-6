import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d, RectBivariateSpline
from scipy.optimize import minimize_scalar
from scipy.integrate import solve_ivp
import math
import time
import pandas as pd # Import pandas to read the new CSV
import os # Import os to check if file exists

# --- 1. CONFIGURATION (Constants & Vehicle Data) ---
GRAVITY_MPS2 = 9.81
AIR_DENSITY_KGM3 = 1.225
FUEL_DENSITY_GPL = 743.0
EARTH_RADIUS_M = 6371000
VEHICLE_MASS_KG = 1400.0
FRONTAL_AREA_M2 = 2.2
DRAG_COEFFICIENT = 0.3
ROLLING_RESISTANCE_COEFFICIENT = 0.015
FIXED_GEAR_RATIOS_LIST = [3.70, 1.95, 1.30, 1.03, 0.84, 0.68]
BASE_FINAL_DRIVE_RATIO = 3.85
TIRE_RADIUS_M = 0.323
MIN_ENGINE_RPM = 800.0
MAX_ENGINE_RPM = 6800.0
FIXED_GEAR_RATIOS_DICT = {i+1: ratio for i, ratio in enumerate(FIXED_GEAR_RATIOS_LIST)}
MPH_TO_MPS = 0.44704 # Conversion constant for miles per hour to m/s
ROUTE_FILENAME = "final_route_highres_elevation_speed_mph.csv"

# --- 2. CORE ENGINE MODEL (INTERPOLATION) ---
(get_fuel_flow, get_max_torque, get_min_torque) = (None, None, None)

def setup_engine_model():
    """ Loads all EPA log data and returns interpolation functions. """
    global get_fuel_flow, get_max_torque, get_min_torque
    speed_rads_axis = np.array([
        0.0, 36.6, 77.9, 88.7, 96.6, 104.6, 131.2, 156.9, 182.5, 
        209.3, 259.3, 310.9, 363.7, 415.8, 470.8, 562.9, 654.5, 680.7
    ])
    torque_nm_axis = np.array([
        -39.9, -37.9, -22.2, 2.2, 9.7, 19.4, 29.6, 39.7, 44.7, 49.6, 
        59.7, 69.6, 79.6, 89.7, 99.5, 109.8, 119.6, 129.5, 138.6, 
        150.3, 169.7, 183.1, 195.9, 211.5
    ])
    fuel_gps_map = np.array([
        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.06,0.09],
        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.01,0.12,0.15],
        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.01,0.03,0.06,0.09,0.17,0.29,0.45,0.61,0.66],
        [0.02,0.07,0.12,0.13,0.14,0.15,0.19,0.22,0.26,0.30,0.37,0.47,0.59,0.71,0.86,1.13,1.39,1.47],
        [0.03,0.08,0.15,0.16,0.18,0.19,0.24,0.28,0.33,0.38,0.47,0.58,0.72,0.86,1.04,1.34,1.64,1.72],
        [0.04,0.11,0.19,0.21,0.23,0.24,0.30,0.35,0.42,0.48,0.59,0.72,0.88,1.06,1.28,1.62,1.95,2.05],
        [0.05,0.14,0.24,0.26,0.28,0.30,0.36,0.43,0.50,0.58,0.71,0.87,1.07,1.30,1.53,1.91,2.29,2.40],
        [0.06,0.16,0.28,0.31,0.33,0.35,0.43,0.50,0.58,0.67,0.84,1.02,1.26,1.53,1.77,2.21,2.64,2.76],
        [0.06,0.17,0.29,0.33,0.35,0.37,0.46,0.54,0.63,0.72,0.90,1.10,1.36,1.64,1.90,2.35,2.81,2.94],
        [0.06,0.18,0.31,0.35,0.37,0.40,0.49,0.58,0.67,0.77,0.97,1.18,1.45,1.75,2.02,2.50,2.97,3.11],
        [0.06,0.20,0.35,0.39,0.42,0.45,0.55,0.66,0.76,0.87,1.10,1.35,1.64,1.97,2.28,2.80,3.32,3.47],
        [0.07,0.22,0.39,0.44,0.47,0.51,0.62,0.74,0.86,0.99,1.24,1.52,1.83,2.18,2.53,3.09,3.67,3.84],
        [0.08,0.25,0.44,0.49,0.53,0.57,0.69,0.82,0.96,1.11,1.38,1.68,2.03,2.40,2.78,3.39,4.03,4.21],
        [0.10,0.28,0.50,0.55,0.59,0.63,0.77,0.92,1.07,1.23,1.53,1.85,2.22,2.62,3.02,3.70,4.40,4.61],
        [0.12,0.32,0.56,0.62,0.66,0.71,0.86,1.01,1.17,1.34,1.67,2.01,2.42,2.84,3.26,4.00,4.77,4.99],
        [0.15,0.37,0.63,0.69,0.74,0.79,0.95,1.11,1.28,1.48,1.82,2.19,2.63,3.07,3.52,4.33,5.17,5.41],
        [0.19,0.43,0.70,0.77,0.83,0.88,1.06,1.23,1.39,1.57,1.96,2.36,2.84,3.30,3.78,4.64,5.55,5.81],
        [0.23,0.49,0.79,0.86,0.92,0.98,1.18,1.37,1.54,1.71,2.10,2.55,3.03,3.52,4.04,4.98,5.95,6.23],
        [0.28,0.56,0.87,0.95,1.01,1.07,1.28,1.48,1.67,1.84,2.24,2.72,3.22,3.73,4.29,5.31,6.32,6.61],
        [0.34,0.64,0.99,1.07,1.14,1.20,1.41,1.61,1.81,2.02,2.46,2.95,3.47,4.03,4.65,5.74,6.81,7.12],
        [0.42,0.79,1.20,1.31,1.39,1.47,1.73,1.97,2.20,2.39,2.98,3.50,4.02,4.69,5.41,6.55,7.65,7.96],
        [0.47,0.88,1.35,1.48,1.57,1.66,1.96,2.25,2.54,2.84,3.50,4.02,4.67,5.32,6.02,7.15,8.24,8.55],
        [0.50,0.97,1.50,1.64,1.74,1.84,2.18,2.51,2.85,3.20,3.85,4.47,5.28,5.97,6.64,7.74,8.81,9.11],
        [0.54,1.08,1.68,1.84,1.95,2.07,2.46,2.84,3.21,3.60,4.32,5.10,5.94,6.70,7.42,8.48,9.51,9.80]
    ])
    
    rads_to_rpm = 60 / (2 * np.pi)
    wot_speed_rads=np.array([0.0,95.0,157.2,178.0,209.5,235.7,256.4,282.7,314.1,356.1,429.4,628.3,680.7])
    wot_torque_nm=np.array([0.0,134.6,164.9,167.8,187.9,188.3,182.3,188.2,201.4,197.4,200.1,184.0,0.0])
    ct_speed_rads=np.array([0.0,146.6,403.2,424.0,465.8,680.7])
    ct_torque_nm=np.array([-16.0,-20.6,-28.8,-33.5,-35.0,-42.7])
    _get_fuel_flow = RectBivariateSpline(torque_nm_axis, speed_rads_axis, fuel_gps_map, kx=1, ky=1)
    _get_max_torque = interp1d(wot_speed_rads * rads_to_rpm, wot_torque_nm, kind='linear', bounds_error=False, fill_value=0.0)
    _get_min_torque = interp1d(ct_speed_rads * rads_to_rpm, ct_torque_nm, kind='linear', bounds_error=False, fill_value=-16.0)
    def get_fuel_flow_gps(rpm, torque):
        rads = rpm * (2 * np.pi / 60)
        torque_clipped = np.clip(torque, torque_nm_axis[0], torque_nm_axis[-1])
        rads_clipped = np.clip(rads, speed_rads_axis[0], speed_rads_axis[-1])
        return _get_fuel_flow(torque_clipped, rads_clipped)[0][0]
    get_fuel_flow = get_fuel_flow_gps
    get_max_torque = _get_max_torque
    get_min_torque = _get_min_torque
    print("Engine model setup complete.")

# --- 3. CORE PHYSICS & ROUTE FUNCTIONS ---
def get_engine_rpm_from_speed(speed_mps, gear_ratio, final_drive):
    if TIRE_RADIUS_M == 0: return 0
    wheel_rpm = (speed_mps / (2 * math.pi * TIRE_RADIUS_M)) * 60
    engine_rpm = wheel_rpm * gear_ratio * final_drive
    return max(MIN_ENGINE_RPM, engine_rpm)
def calculate_resistance_forces(speed_mps, slope_percent):
    f_drag = 0.5 * AIR_DENSITY_KGM3 * FRONTAL_AREA_M2 * DRAG_COEFFICIENT * (speed_mps ** 2)
    f_rolling = ROLLING_RESISTANCE_COEFFICIENT * VEHICLE_MASS_KG * GRAVITY_MPS2
    slope_angle_rad = math.atan(slope_percent / 100.0)
    f_gravity = VEHICLE_MASS_KG * GRAVITY_MPS2 * math.sin(slope_angle_rad)
    return f_drag + f_rolling + f_gravity

# --- 4. ROUTE PRE-PROCESSING (MODIFIED TO READ POINT-BY-POINT) ---
# This list will hold our simplified route segments
PROCESSED_ROUTE = []

def preprocess_route():
    """
    Loads the route CSV from route_mapper.py and processes it
    into a "micro-segment" for *every point* in the file.
    """
    global PROCESSED_ROUTE
    PROCESSED_ROUTE = []
    
    print(f"Pre-processing route data from '{ROUTE_FILENAME}'...")
    
    try:
        df_route = pd.read_csv(ROUTE_FILENAME)
    except FileNotFoundError:
        print(f"‚ùå ERROR: Route file not found: '{ROUTE_FILENAME}'")
        print("Please run 'route_mapper.py' first to generate the route.")
        return False
    except Exception as e:
        print(f"‚ùå ERROR: Could not read route file: {e}")
        return False

    # --- NEW LOGIC: Create a segment for EVERY POINT ---
    
    # Calculate elevation change to the *next* point
    df_route['elev_next'] = df_route['elev_m'].shift(-1)
    df_route['elev_change_m'] = df_route['elev_next'] - df_route['elev_m']
    
    # Calculate slope for this specific segment
    # (elev_change / dist_change)
    df_route['dist_to_next_safe'] = df_route['distance_to_next_m'].replace(0, 1e-6) # Avoid div by zero
    df_route['slope_pct'] = (df_route['elev_change_m'] / df_route['dist_to_next_safe']) * 100
    
    # Convert speed limit to m/s
    df_route['speed_limit_mps'] = df_route['speed_limit_mph'] * MPH_TO_MPS
    
    # Drop the last row, which has no "next point"
    df_route = df_route.iloc[:-1]
    
    # Convert the DataFrame into the list of tuples our simulator expects
    PROCESSED_ROUTE = list(zip(
        df_route['distance_to_next_m'],
        df_route['slope_pct'],
        df_route['speed_limit_mps']
    ))
    
    total_dist_km = sum([seg[0] for seg in PROCESSED_ROUTE]) / 1000.0
    print(f"Route pre-processed. {len(PROCESSED_ROUTE)} micro-segments. Total distance: {total_dist_km:.1f} km")
    return True

# --- 5. HYBRID SIMULATION "MINI-FUNCTIONS" ---
_cruise_cache_key = None
_cruise_cache_solution = (0.0, 0.0) # (fuel_flow_gps, time_per_meter)

def clear_cruise_cache():
    global _cruise_cache_key, _cruise_cache_solution
    _cruise_cache_key = None
    _cruise_cache_solution = (0.0, 0.0)

def simulate_cruise(speed_mps, slope_pct, distance_m, final_drive_ratio):
    """
    NON-ODE calculation for the constant-speed cruise part.
    This is the "constant df/dt" part of your brief.
    """
    global _cruise_cache_key, _cruise_cache_solution
    
    # --- Caching Logic ---
    cache_key = (speed_mps, slope_pct, final_drive_ratio)
    if cache_key == _cruise_cache_key:
        (fuel_flow_gps, time_per_meter) = _cruise_cache_solution
    else:
        # --- CACHE MISS: Run the 6-gear-check *once* ---
        f_resistance = calculate_resistance_forces(speed_mps, slope_pct)
        wheel_torque_req = f_resistance * TIRE_RADIUS_M
        
        best_fuel_flow = float('inf')
        
        for gear, ratio in FIXED_GEAR_RATIOS_DICT.items():
            rpm = get_engine_rpm_from_speed(speed_mps, ratio, final_drive_ratio)
            if rpm < MIN_ENGINE_RPM or rpm > MAX_ENGINE_RPM: continue
            
            engine_tq_req = (wheel_torque_req) / (ratio * final_drive_ratio)
            
            if engine_tq_req < get_min_torque(rpm) or engine_tq_req > get_max_torque(rpm):
                continue
            
            current_fuel_flow = get_fuel_flow(rpm, engine_tq_req)
            if engine_tq_req < 0: current_fuel_flow = 0.0 # DFCO
            
            if current_fuel_flow < best_fuel_flow:
                best_fuel_flow = current_fuel_flow
        
        fuel_flow_gps = best_fuel_flow
        if fuel_flow_gps == float('inf'): # If no gear can hold this speed
            fuel_flow_gps = 0.0 # Fail safe (e.g. too steep)
            
        time_per_meter = 1.0 / speed_mps if speed_mps > 0.01 else 0.0
        
        # Save to cache
        _cruise_cache_key = cache_key
        _cruise_cache_solution = (fuel_flow_gps, time_per_meter)
        
    # --- End Caching Logic ---
    
    time_taken_sec = 0.0
    fuel_used_grams = 0.0

    if speed_mps > 0.01:    
        time_taken_sec = time_per_meter * distance_m
        fuel_used_grams = fuel_flow_gps * time_taken_sec
    
    return fuel_used_grams, time_taken_sec

def _accel_ode_model(t, y, slope_pct, final_drive_ratio):
    """
    The physics model *only* for acceleration at 80% torque.
    y = [speed_mps, fuel_grams, distance_meters]
    """
    speed_mps = max(0.1, y[0]) # Avoid division by zero
    
    # Find best *power* gear (80% torque rule)
    best_power_gear_ratio = FIXED_GEAR_RATIOS_LIST[0]
    max_possible_wheel_torque = -float('inf')
    
    for gear, ratio in FIXED_GEAR_RATIOS_DICT.items():
        rpm = get_engine_rpm_from_speed(speed_mps, ratio, final_drive_ratio)
        if rpm > MAX_ENGINE_RPM: continue
        engine_tq_max = get_max_torque(rpm)
        wheel_tq = (engine_tq_max * ratio * final_drive_ratio)
        if wheel_tq > max_possible_wheel_torque:
            max_possible_wheel_torque = wheel_tq
            best_power_gear_ratio = ratio
    
    # Get stats for the best power gear
    rpm_at_max_power = get_engine_rpm_from_speed(speed_mps, best_power_gear_ratio, final_drive_ratio)
    engine_torque_req = get_max_torque(rpm_at_max_power) * 0.80
    fuel_flow_gps = get_fuel_flow(rpm_at_max_power, engine_torque_req)
    
    f_tractive = (engine_torque_req * best_power_gear_ratio * final_drive_ratio) / TIRE_RADIUS_M
    f_resistance = calculate_resistance_forces(speed_mps, slope_pct)
    f_net = f_tractive - f_resistance
    acceleration_mps2 = f_net / VEHICLE_MASS_KG
    
    # Return derivatives [dspeed/dt, dfuel/dt, ddistance/dt]
    return [acceleration_mps2, fuel_flow_gps, speed_mps]

def simulate_acceleration(start_speed_mps, target_speed_mps, slope_pct, final_drive_ratio):
    """
    The ODE "mini-simulator" for the acceleration part.
    """
    initial_state = [start_speed_mps, 0.0, 0.0] # [speed, fuel, distance]
    
    # Stop the ODE when we hit the target speed
    def hit_target_speed(t, y, slope_pct, final_drive_ratio):
        return y[0] - target_speed_mps
    hit_target_speed.terminal = True # Stop simulation
    hit_target_speed.direction = 1  # Stop when speed *increases* to the target
    
    sol = solve_ivp(
        _accel_ode_model,
        [0, 30], # Max 30 seconds for this accel (as per your brief)
        initial_state,
        method='RK23',
        events=hit_target_speed,
        args=(slope_pct, final_drive_ratio),
        dense_output=True
    )
    
    if not sol.success or len(sol.y[0]) < 2:
        # Failed to accelerate (e.g., hill too steep)
        return 0.0, 0.0, 0.0, start_speed_mps # 0 fuel, 0 time, 0 dist
    
    fuel_used_grams = sol.y[1][-1]
    time_taken_sec = sol.t[-1]
    distance_covered_m = sol.y[2][-1]
    final_speed_mps = sol.y[0][-1]
    
    return fuel_used_grams, time_taken_sec, distance_covered_m, final_speed_mps

# --- 6. HYBRID SIMULATION ENGINE ---

def run_segment_simulation(final_drive_ratio):
    """
    This is the "Brain" of the simulation.
    It loops through the pre-processed (now point-by-point) route segments.
    """
    total_fuel_grams = 0.0
    total_time_sec = 0.0
    current_speed_mps = 0.0 # Start from 0
    
    # PROCESSED_ROUTE is now a list of *hundreds* of "micro-segments"
    for (seg_dist_m, seg_slope_pct, seg_speed_limit_mps) in PROCESSED_ROUTE:
        
        target_speed_mps = seg_speed_limit_mps
        
        if target_speed_mps > current_speed_mps:
            # --- 1. ACCELERATION CASE ---
            (fuel_g, time_s, dist_m, final_speed) = simulate_acceleration(
                current_speed_mps, target_speed_mps, seg_slope_pct, final_drive_ratio
            )
            
            total_fuel_grams += fuel_g
            total_time_sec += time_s
            current_speed_mps = final_speed
            
            # Cruise for the *rest* of the segment
            remaining_distance_m = seg_dist_m - dist_m
            if remaining_distance_m > 0:
                (fuel_g_cruise, time_s_cruise) = simulate_cruise(
                    current_speed_mps, seg_slope_pct, remaining_distance_m, final_drive_ratio
                )
                total_fuel_grams += fuel_g_cruise
                total_time_sec += time_s_cruise
                
        elif target_speed_mps < current_speed_mps:
            # --- 2. DECELERATION CASE ---
            # "Instant drop in speed, 0 fuel"
            current_speed_mps = target_speed_mps
            
            # Cruise at the *new, lower speed* for the whole segment
            (fuel_g_cruise, time_s_cruise) = simulate_cruise(
                current_speed_mps, seg_slope_pct, seg_dist_m, final_drive_ratio
            )
            total_fuel_grams += fuel_g_cruise
            total_time_sec += time_s_cruise
            
        else:
            # --- 3. CRUISING CASE ---
            # Speed limit is the same as last segment
            (fuel_g_cruise, time_s_cruise) = simulate_cruise(
                current_speed_mps, seg_slope_pct, seg_dist_m, final_drive_ratio
            )
            total_fuel_grams += fuel_g_cruise
            total_time_sec += time_s_cruise
            
    return total_fuel_grams / FUEL_DENSITY_GPL # Return total Liters

# --- 7. OPTIMIZATION PROBLEM SETUP ---

def objective_function(final_drive_ratio):
    """
    The "Worker" function.
    1. Clears the cache.
    2. Runs the new hybrid simulation.
    """
    start_time = time.time()
    
    # 1. Clear the cache for this new ratio
    clear_cruise_cache()
    
    # 2. Run the hybrid simulation
    fuel_liters = run_segment_simulation(final_drive_ratio)
    
    end_time = time.time()
    cost = fuel_liters
    
    if fuel_liters == 0.0:
        print(f"  FD: {final_drive_ratio:.3f} | Simulation FAILED (Cost: 0.0 L) | Time: {end_time - start_time:.2f}s")
        return float('inf')
        
    print(f"  FD: {final_drive_ratio:.3f} | Cost: {cost:.5f} L | Time: {end_time - start_time:.2f}s")
    return cost

# --- 8. MAIN EXECUTION ---
if __name__ == "__main__":
    try:
        setup_engine_model()
        
        # --- MODIFICATION: Check if route processing was successful ---
        if not preprocess_route():
            # Stop execution if the route file wasn't found
            raise SystemExit("\nüõë Halting execution. Please run 'route_mapper.py' first.")
        
        print("\n--- Hybrid Final Drive Ratio Optimization (Point-by-Point) ---")
        
        print("\nCalculating baseline fuel economy with initial ratio:")
        baseline_fuel = objective_function(BASE_FINAL_DRIVE_RATIO)
        
        if baseline_fuel == float('inf'):
            print("Baseline simulation failed. Cannot proceed with optimization.")
        else:
            print(f"Baseline Fuel Consumption: {baseline_fuel:.5f} Liters")
            print("\n--- STARTING 1D OPTIMIZATION ---")
            
            result = minimize_scalar(
                objective_function,
                bounds=(2.0, 4.5), # Search between these final drive ratios
                method='bounded',
                options={'xatol': 0.01} # Find answer within 0.01 ratio
            )
            
            print("\n--- OPTIMIZATION COMPLETE ---")
            
            if result.success:
                optimal_ratio = result.x
                final_fuel_cost = result.fun
                print(f"Baseline Ratio: {BASE_FINAL_DRIVE_RATIO:.3f} | Fuel: {baseline_fuel:.5f} L")
                print(f"Optimal Ratio:  {optimal_ratio:.3f} | Fuel: {final_fuel_cost:.5f} L")
                fuel_saved = baseline_fuel - final_fuel_cost
                percent_saved = (fuel_saved / baseline_fuel) * 100
                print(f"\nFuel Saved: {fuel_saved:.5f} L ({percent_saved:.2f}% improvement)")
            else:
                print("Optimization did not converge.")

    except ImportError:
        print("\n--- ERROR ---")
        print("This script requires 'numpy', 'matplotlib', 'scipy', and 'pandas'.")
        print("Please install them by running:")
        print("pip install numpy matplotlib scipy pandas")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
