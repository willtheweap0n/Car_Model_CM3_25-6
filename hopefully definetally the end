import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d, RectBivariateSpline
from scipy.optimize import minimize_scalar, fsolve
from scipy.integrate import solve_ivp
import math
import time
import pandas as pd # Import pandas to read the new CSV
import os # Import os to check if file exists

# --- Imports from route_mapper.py ---
from scipy.spatial import cKDTree
import requests
import osmnx as ox
import geopandas as gpd
from shapely.geometry import Point
import re
import json
# --- End of imports ---


# --- 1. CONFIGURATION (Constants & Vehicle Data) ---
GRAVITY_MPS2 = 9.81
AIR_DENSITY_KGM3 = 1.225
FUEL_DENSITY_GPL = 743.0
EARTH_RADIUS_M = 6371000
VEHICLE_MASS_KG = 1400.0
FRONTAL_AREA_M2 = 2.2
DRAG_COEFFICIENT = 0.3
ROLLING_RESISTANCE_COEFFICIENT = 0.015
FIXED_GEAR_RATIOS_LIST = [3.70, 1.95, 1.30, 1.03, 0.84, 0.68]
BASE_FINAL_DRIVE_RATIO = 3.85
TIRE_RADIUS_M = 0.323
MIN_ENGINE_RPM = 800.0
MAX_ENGINE_RPM = 6800.0
FIXED_GEAR_RATIOS_DICT = {i+1: ratio for i, ratio in enumerate(FIXED_GEAR_RATIOS_LIST)}
MPH_TO_MPS = 0.44704 # Conversion constant for miles per hour to m/s
ROUTE_FILENAME = "final_route_highres_elevation_speed_mph.csv"

# --- 2. CORE ENGINE MODEL (INTERPOLATION) ---
(get_fuel_flow, get_max_torque, get_min_torque) = (None, None, None)

def setup_engine_model():
    """ Loads all EPA log data and returns interpolation functions. """
    global get_fuel_flow, get_max_torque, get_min_torque
    speed_rads_axis = np.array([
        0.0, 36.6, 77.9, 88.7, 96.6, 104.6, 131.2, 156.9, 182.5, 
        209.3, 259.3, 310.9, 363.7, 415.8, 470.8, 562.9, 654.5, 680.7
    ])
    torque_nm_axis = np.array([
        -39.9, -37.9, -22.2, 2.2, 9.7, 19.4, 29.6, 39.7, 44.7, 49.6, 
        59.7, 69.6, 79.6, 89.7, 99.5, 109.8, 119.6, 129.5, 138.6, 
        150.3, 169.7, 183.1, 195.9, 211.5
    ])
    fuel_gps_map = np.array([
        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.06,0.09],
        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.01,0.12,0.15],
        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.01,0.03,0.06,0.09,0.17,0.29,0.45,0.61,0.66],
        [0.02,0.07,0.12,0.13,0.14,0.15,0.19,0.22,0.26,0.30,0.37,0.47,0.59,0.71,0.86,1.13,1.39,1.47],
        [0.03,0.08,0.15,0.16,0.18,0.19,0.24,0.28,0.33,0.38,0.47,0.58,0.72,0.86,1.04,1.34,1.64,1.72],
        [0.04,0.11,0.19,0.21,0.23,0.24,0.30,0.35,0.42,0.48,0.59,0.72,0.88,1.06,1.28,1.62,1.95,2.05],
        [0.05,0.14,0.24,0.26,0.28,0.30,0.36,0.43,0.50,0.58,0.71,0.87,1.07,1.30,1.53,1.91,2.29,2.40],
        [0.06,0.16,0.28,0.31,0.33,0.35,0.43,0.50,0.58,0.67,0.84,1.02,1.26,1.53,1.77,2.21,2.64,2.76],
        [0.06,0.17,0.29,0.33,0.35,0.37,0.46,0.54,0.63,0.72,0.90,1.10,1.36,1.64,1.90,2.35,2.81,2.94],
        [0.06,0.18,0.31,0.35,0.37,0.40,0.49,0.58,0.67,0.77,0.97,1.18,1.45,1.75,2.02,2.50,2.97,3.11],
        [0.06,0.20,0.35,0.39,0.42,0.45,0.55,0.66,0.76,0.87,1.10,1.35,1.64,1.97,2.28,2.80,3.32,3.47],
        [0.07,0.22,0.39,0.44,0.47,0.51,0.62,0.74,0.86,0.99,1.24,1.52,1.83,2.18,2.53,3.09,3.67,3.84],
        [0.08,0.25,0.44,0.49,0.53,0.57,0.69,0.82,0.96,1.11,1.38,1.68,2.03,2.40,2.78,3.39,4.03,4.21],
        [0.10,0.28,0.50,0.55,0.59,0.63,0.77,0.92,1.07,1.23,1.53,1.85,2.22,2.62,3.02,3.70,4.40,4.61],
        [0.12,0.32,0.56,0.62,0.66,0.71,0.86,1.01,1.17,1.34,1.67,2.01,2.42,2.84,3.26,4.00,4.77,4.99],
        [0.15,0.37,0.63,0.69,0.74,0.79,0.95,1.11,1.28,1.48,1.82,2.19,2.63,3.07,3.52,4.33,5.17,5.41],
        [0.19,0.43,0.70,0.77,0.83,0.88,1.06,1.23,1.39,1.57,1.96,2.36,2.84,3.30,3.78,4.64,5.55,5.81],
        [0.23,0.49,0.79,0.86,0.92,0.98,1.18,1.37,1.54,1.71,2.10,2.55,3.03,3.52,4.04,4.98,5.95,6.23],
        [0.28,0.56,0.87,0.95,1.01,1.07,1.28,1.48,1.67,1.84,2.24,2.72,3.22,3.73,4.29,5.31,6.32,6.61],
        [0.34,0.64,0.99,1.07,1.14,1.20,1.41,1.61,1.81,2.02,2.46,2.95,3.47,4.03,4.65,5.74,6.81,7.12],
        [0.42,0.79,1.20,1.31,1.39,1.47,1.73,1.97,2.20,2.39,2.98,3.50,4.02,4.69,5.41,6.55,7.65,7.96],
        [0.47,0.88,1.35,1.48,1.57,1.66,1.96,2.25,2.54,2.84,3.50,4.02,4.67,5.32,6.02,7.15,8.24,8.55],
        [0.50,0.97,1.50,1.64,1.74,1.84,2.18,2.51,2.85,3.20,3.85,4.47,5.28,5.97,6.64,7.74,8.81,9.11],
        [0.54,1.08,1.68,1.84,1.95,2.07,2.46,2.84,3.21,3.60,4.32,5.10,5.94,6.70,7.42,8.48,9.51,9.80]
    ])
    
    rads_to_rpm = 60 / (2 * np.pi)
    wot_speed_rads=np.array([0.0,95.0,157.2,178.0,209.5,235.7,256.4,282.7,314.1,356.1,429.4,628.3,680.7])
    wot_torque_nm=np.array([0.0,134.6,164.9,167.8,187.9,188.3,182.3,188.2,201.4,197.4,200.1,184.0,0.0])
    ct_speed_rads=np.array([0.0,146.6,403.2,424.0,465.8,680.7])
    ct_torque_nm=np.array([-16.0,-20.6,-28.8,-33.5,-35.0,-42.7])
    _get_fuel_flow = RectBivariateSpline(torque_nm_axis, speed_rads_axis, fuel_gps_map, kx=1, ky=1)
    _get_max_torque = interp1d(wot_speed_rads * rads_to_rpm, wot_torque_nm, kind='linear', bounds_error=False, fill_value=0.0)
    _get_min_torque = interp1d(ct_speed_rads * rads_to_rpm, ct_torque_nm, kind='linear', bounds_error=False, fill_value=-16.0)
    
    def get_fuel_flow_gps(rpm, torque):
        rads = rpm * (2 * np.pi / 60)
        torque_clipped = np.clip(torque, torque_nm_axis[0], torque_nm_axis[-1])
        rads_clipped = np.clip(rads, speed_rads_axis[0], speed_rads_axis[-1])
        return _get_fuel_flow(torque_clipped, rads_clipped)[0][0]
        
    get_fuel_flow = get_fuel_flow_gps
    get_max_torque = _get_max_torque
    get_min_torque = _get_min_torque
    print("Engine model setup complete.")

# --- 3. CORE PHYSICS FUNCTIONS ---
def get_engine_rpm_from_speed(speed_mps, gear_ratio, final_drive):
    if TIRE_RADIUS_M == 0: return 0
    wheel_rpm = (speed_mps / (2 * math.pi * TIRE_RADIUS_M)) * 60
    engine_rpm = wheel_rpm * gear_ratio * final_drive
    return max(MIN_ENGINE_RPM, engine_rpm)

def calculate_resistance_forces(speed_mps, slope_percent):
    f_drag = 0.5 * AIR_DENSITY_KGM3 * FRONTAL_AREA_M2 * DRAG_COEFFICIENT * (speed_mps ** 2)
    f_rolling = ROLLING_RESISTANCE_COEFFICIENT * VEHICLE_MASS_KG * GRAVITY_MPS2
    slope_angle_rad = math.atan(slope_percent / 100.0)
    f_gravity = VEHICLE_MASS_KG * GRAVITY_MPS2 * math.sin(slope_angle_rad)
    return f_drag + f_rolling + f_gravity

# --- 4. ROUTE PRE-PROCESSING (from hybrid_optimizer.py) ---
PROCESSED_ROUTE = []

def preprocess_route():
    """
    Loads the route CSV from route_mapper.py and processes it
    into a "micro-segment" for *every point* in the file.
    """
    global PROCESSED_ROUTE
    PROCESSED_ROUTE = []
    
    print(f"Pre-processing route data from '{ROUTE_FILENAME}'...")
    
    try:
        df_route = pd.read_csv(ROUTE_FILENAME)
    except FileNotFoundError:
        print(f"‚ùå ERROR: Route file not found: '{ROUTE_FILENAME}'")
        print("Please run 'route_mapper.py' (part of this script) first to generate the route.")
        return False
    except Exception as e:
        print(f"‚ùå ERROR: Could not read route file: {e}")
        return False

    # Create a segment for EVERY POINT
    df_route['elev_next'] = df_route['elev_m'].shift(-1)
    df_route['elev_change_m'] = df_route['elev_next'] - df_route['elev_m']
    df_route['dist_to_next_safe'] = df_route['distance_to_next_m'].replace(0, 1e-6)
    df_route['slope_pct'] = (df_route['elev_change_m'] / df_route['dist_to_next_safe']) * 100
    df_route['speed_limit_mps'] = df_route['speed_limit_mph'] * MPH_TO_MPS
    df_route = df_route.iloc[:-1] # Drop the last row (no "next point")
    
    PROCESSED_ROUTE = list(zip(
        df_route['distance_to_next_m'],
        df_route['slope_pct'],
        df_route['speed_limit_mps']
    ))
    
    total_dist_km = sum([seg[0] for seg in PROCESSED_ROUTE]) / 1000.0
    print(f"Route pre-processed. {len(PROCESSED_ROUTE)} micro-segments. Total distance: {total_dist_km:.1f} km")
    return True

# --- 5. HYBRID SIMULATION "MINI-FUNCTIONS" ---
_cruise_cache_key = None
_cruise_cache_solution = (0.0, 0.0) # (fuel_flow_gps, time_per_meter)

def clear_cruise_cache():
    global _cruise_cache_key, _cruise_cache_solution
    _cruise_cache_key = None
    _cruise_cache_solution = (0.0, 0.0)

def simulate_cruise(speed_mps, slope_pct, distance_m, final_drive_ratio):
    """
    NON-ODE calculation for the constant-speed cruise part.
    """
    global _cruise_cache_key, _cruise_cache_solution
    
    cache_key = (speed_mps, slope_pct, final_drive_ratio)
    if cache_key == _cruise_cache_key:
        (fuel_flow_gps, time_per_meter) = _cruise_cache_solution
    else:
        f_resistance = calculate_resistance_forces(speed_mps, slope_pct)
        wheel_torque_req = f_resistance * TIRE_RADIUS_M
        best_fuel_flow = float('inf')
        
        for gear, ratio in FIXED_GEAR_RATIOS_DICT.items():
            rpm = get_engine_rpm_from_speed(speed_mps, ratio, final_drive_ratio)
            if rpm < MIN_ENGINE_RPM or rpm > MAX_ENGINE_RPM: continue
            
            engine_tq_req = (wheel_torque_req) / (ratio * final_drive_ratio)
            
            if engine_tq_req < get_min_torque(rpm) or engine_tq_req > get_max_torque(rpm):
                continue
            
            current_fuel_flow = get_fuel_flow(rpm, engine_tq_req)
            if engine_tq_req < 0: current_fuel_flow = 0.0 # DFCO
            
            if current_fuel_flow < best_fuel_flow:
                best_fuel_flow = current_fuel_flow
        
        fuel_flow_gps = best_fuel_flow
        if fuel_flow_gps == float('inf'):
            fuel_flow_gps = 0.0
            
        time_per_meter = 1.0 / speed_mps if speed_mps > 0.01 else 0.0
        
        _cruise_cache_key = cache_key
        _cruise_cache_solution = (fuel_flow_gps, time_per_meter)
        
    time_taken_sec = 0.0
    fuel_used_grams = 0.0
    if speed_mps > 0.01:    
        time_taken_sec = time_per_meter * distance_m
        fuel_used_grams = fuel_flow_gps * time_taken_sec
    
    return fuel_used_grams, time_taken_sec

def _accel_ode_model(t, y, slope_pct, final_drive_ratio):
    """
    The physics model *only* for acceleration at 80% torque.
    """
    speed_mps = max(0.1, y[0])
    best_power_gear_ratio = FIXED_GEAR_RATIOS_LIST[0]
    max_possible_wheel_torque = -float('inf')
    
    for gear, ratio in FIXED_GEAR_RATIOS_DICT.items():
        rpm = get_engine_rpm_from_speed(speed_mps, ratio, final_drive_ratio)
        if rpm > MAX_ENGINE_RPM: continue
        engine_tq_max = get_max_torque(rpm)
        wheel_tq = (engine_tq_max * ratio * final_drive_ratio)
        if wheel_tq > max_possible_wheel_torque:
            max_possible_wheel_torque = wheel_tq
            best_power_gear_ratio = ratio
    
    rpm_at_max_power = get_engine_rpm_from_speed(speed_mps, best_power_gear_ratio, final_drive_ratio)
    engine_torque_req = get_max_torque(rpm_at_max_power) * 0.80
    fuel_flow_gps = get_fuel_flow(rpm_at_max_power, engine_torque_req)
    
    f_tractive = (engine_torque_req * best_power_gear_ratio * final_drive_ratio) / TIRE_RADIUS_M
    f_resistance = calculate_resistance_forces(speed_mps, slope_pct)
    f_net = f_tractive - f_resistance
    acceleration_mps2 = f_net / VEHICLE_MASS_KG
    
    return [acceleration_mps2, fuel_flow_gps, speed_mps]

def simulate_acceleration(start_speed_mps, target_speed_mps, slope_pct, final_drive_ratio):
    """
    The ODE "mini-simulator" for the acceleration part.
    """
    initial_state = [start_speed_mps, 0.0, 0.0]
    
    def hit_target_speed(t, y, slope_pct, final_drive_ratio):
        return y[0] - target_speed_mps
    hit_target_speed.terminal = True
    hit_target_speed.direction = 1
    
    sol = solve_ivp(
        _accel_ode_model, [0, 30], initial_state, method='RK23',
        events=hit_target_speed, args=(slope_pct, final_drive_ratio), dense_output=True
    )
    
    if not sol.success or len(sol.y[0]) < 2:
        return 0.0, 0.0, 0.0, start_speed_mps
    
    fuel_used_grams = sol.y[1][-1]
    time_taken_sec = sol.t[-1]
    distance_covered_m = sol.y[2][-1]
    final_speed_mps = sol.y[0][-1]
    
    return fuel_used_grams, time_taken_sec, distance_covered_m, final_speed_mps

# --- 6. HYBRID SIMULATION ENGINE ---
def run_segment_simulation(final_drive_ratio):
    """
    This is the "Brain" of the simulation.
    It loops through the pre-processed (now point-by-point) route segments.
    """
    total_fuel_grams = 0.0
    total_time_sec = 0.0
    current_speed_mps = 0.0
    
    for (seg_dist_m, seg_slope_pct, seg_speed_limit_mps) in PROCESSED_ROUTE:
        target_speed_mps = seg_speed_limit_mps
        
        if target_speed_mps > current_speed_mps:
            (fuel_g, time_s, dist_m, final_speed) = simulate_acceleration(
                current_speed_mps, target_speed_mps, seg_slope_pct, final_drive_ratio
            )
            total_fuel_grams += fuel_g
            total_time_sec += time_s
            current_speed_mps = final_speed
            
            remaining_distance_m = seg_dist_m - dist_m
            if remaining_distance_m > 0:
                (fuel_g_cruise, time_s_cruise) = simulate_cruise(
                    current_speed_mps, seg_slope_pct, remaining_distance_m, final_drive_ratio
                )
                total_fuel_grams += fuel_g_cruise
                total_time_sec += time_s_cruise
                
        elif target_speed_mps < current_speed_mps:
            current_speed_mps = target_speed_mps
            (fuel_g_cruise, time_s_cruise) = simulate_cruise(
                current_speed_mps, seg_slope_pct, seg_dist_m, final_drive_ratio
            )
            total_fuel_grams += fuel_g_cruise
            total_time_sec += time_s_cruise
            
        else:
            (fuel_g_cruise, time_s_cruise) = simulate_cruise(
                current_speed_mps, seg_slope_pct, seg_dist_m, final_drive_ratio
            )
            total_fuel_grams += fuel_g_cruise
            total_time_sec += time_s_cruise
            
    return total_fuel_grams / FUEL_DENSITY_GPL

# --- 7. OPTIMIZATION PROBLEM SETUP ---
def objective_function(final_drive_ratio):
    """ The "Worker" function. """
    start_time = time.time()
    clear_cruise_cache()
    fuel_liters = run_segment_simulation(final_drive_ratio)
    end_time = time.time()
    cost = fuel_liters
    
    if fuel_liters == 0.0:
        print(f"  FD: {final_drive_ratio:.3f} | Simulation FAILED (Cost: 0.0 L) | Time: {end_time - start_time:.2f}s")
        return float('inf')
        
    print(f"  FD: {final_drive_ratio:.3f} | Cost: {cost:.5f} L | Time: {end_time - start_time:.2f}s")
    return cost

# --- 8. ROUTE MAPPER FUNCTIONS (from route_mapper.py) ---
# All functions from your script are now part of this file

def get_elevation_data(df_route, num_points=50):
    print("‚õ∞Ô∏è  Generating elevation data...")
    if len(df_route) > num_points:
        indices = np.linspace(0, len(df_route)-1, num_points, dtype=int)
        df_sparse = df_route.iloc[indices].copy()
    else:
        df_sparse = df_route.copy()
    elevation = generate_realistic_elevation(len(df_sparse))
    df_sparse['elev_m'] = elevation
    return df_sparse

def generate_realistic_elevation(num_points):
    x = np.linspace(0, 4*np.pi, num_points)
    elevation = 50 + 80 * np.sin(x) + 30 * np.sin(2*x + 1) + np.random.normal(0, 8, num_points)
    elevation = np.maximum(elevation, 10)
    return np.round(elevation, 1)

def interpolate_elevation(df_dense, df_sparse):
    print("   - Interpolating elevation...")
    tree = cKDTree(df_sparse[["lon", "lat"]].values)
    distances, indices = tree.query(df_dense[["lon", "lat"]].values, k=1)
    df_dense["elev_m"] = df_sparse.iloc[indices]["elev_m"].values
    df_dense["elev_m"] = df_dense["elev_m"].rolling(window=5, center=True, min_periods=1).mean()
    return df_dense

def calculate_point_distances(df_route):
    print("   - Calculating point distances...")
    distances = np.zeros(len(df_route))
    # Use the haversine_distance from Section 3
    for i in range(len(df_route)-1):
        lat1, lon1 = df_route.iloc[i][['lat', 'lon']]
        lat2, lon2 = df_route.iloc[i+1][['lat', 'lon']]
        distances[i] = haversine_distance(lat1, lon1, lat2, lon2)
    df_route['distance_to_next_m'] = distances
    return df_route

def segment_route(df_route):
    print("   - Segmenting route...")
    df_route['segment_id'] = 0
    df_route['segment_type'] = 'unknown'
    current_segment = 0; segment_start = 0; min_segment_length = 5
    for i in range(1, len(df_route)):
        segment_length = i - segment_start; new_segment = False
        if segment_length >= min_segment_length:
            recent_distances = df_route.iloc[max(segment_start, i-5):i]['distance_to_next_m']
            if len(recent_distances) > 1 and np.std(recent_distances) > 50: new_segment = True
            recent_elevations = df_route.iloc[max(segment_start, i-5):i]['elev_m']
            if len(recent_elevations) > 1 and abs(recent_elevations.iloc[-1] - recent_elevations.iloc[0]) > 15: new_segment = True
            if segment_length >= 30: new_segment = True
        if new_segment:
            segment_points = df_route.iloc[segment_start:i]
            segment_type = classify_segment(segment_points)
            df_route.loc[segment_start:i, 'segment_id'] = current_segment
            df_route.loc[segment_start:i, 'segment_type'] = segment_type
            current_segment += 1; segment_start = i
    if segment_start < len(df_route):
        segment_points = df_route.iloc[segment_start:]
        segment_type = classify_segment(segment_points)
        df_route.loc[segment_start:, 'segment_id'] = current_segment
        df_route.loc[segment_start:, 'segment_type'] = segment_type
    print(f"   - Created {current_segment + 1} segments")
    return df_route

def classify_segment(segment_df):
    if len(segment_df) < 2: return 'unknown'
    avg_distance = segment_df['distance_to_next_m'].mean()
    total_distance = segment_df['distance_to_next_m'].sum()
    elev_std = segment_df['elev_m'].std()
    if avg_distance > 80 and total_distance > 800: return 'highway'
    elif avg_distance > 50: return 'primary'
    elif elev_std > 12: return 'hilly'
    elif total_distance < 300: return 'urban'
    else: return 'secondary'

def assign_speed_limits_mpH(df_route):
    print("   - Assigning speed limits (MPH)...")
    speed_limits_mpH = {'highway': 70, 'primary': 50, 'secondary': 40, 'hilly': 30, 'urban': 20, 'unknown': 30}
    df_route['speed_limit_mph'] = df_route['segment_type'].map(speed_limits_mpH)
    return df_route

def enhance_with_osm_speeds_mpH(df_route):
    print("   - Enhancing with OpenStreetMap data (this may take a moment)...")
    try:
        geometry = [Point(lon, lat) for lon, lat in zip(df_route['lon'], df_route['lat'])]
        gdf_route = gpd.GeoDataFrame(df_route, geometry=geometry, crs='EPSG:4326')
        bounds = gdf_route.total_bounds; buffer_degree = 0.02
        north, south, east, west = (bounds[3] + buffer_degree, bounds[1] - buffer_degree, bounds[2] + buffer_degree, bounds[0] - buffer_degree)
        G = ox.graph_from_bbox(north, south, east, west, network_type='drive')
        gdf_roads = ox.graph_to_gdfs(G, nodes=False); gdf_roads = gdf_roads.to_crs(gdf_route.crs)
        gdf_joined = gpd.sjoin_nearest(gdf_route, gdf_roads[['maxspeed', 'highway', 'geometry']], how='left', distance_col='distance_to_road')
        def parse_osm_speed_to_mph(speed_str):
            if pd.isna(speed_str): return None
            if isinstance(speed_str, (int, float)): return kmh_to_mph(float(speed_str))
            speed_str = str(speed_str).lower()
            if 'mph' in speed_str:
                numbers = re.findall(r'\d+', speed_str)
                if numbers: return float(numbers[0])
            elif any(x in speed_str for x in ['kmh', 'km/h']):
                numbers = re.findall(r'\d+', speed_str)
                if numbers: return kmh_to_mph(float(numbers[0]))
            elif speed_str.isdigit():
                return kmh_to_mph(float(speed_str))
            return None
        gdf_joined['osm_speed_limit_mph'] = gdf_joined['maxspeed'].apply(parse_osm_speed_to_mph)
        valid_osm_mask = gdf_joined['osm_speed_limit_mph'].notna()
        df_route.loc[valid_osm_mask, 'speed_limit_mph'] = gdf_joined.loc[valid_osm_mask, 'osm_speed_limit_mph']
        print(f"   - Updated {valid_osm_mask.sum()} points with OSM speed limits")
    except Exception as e:
        print(f"   - OSM enhancement skipped: {e}")
    return df_route

def kmh_to_mph(kmh): return round(kmh * 0.621371, 1)
def mph_to_kmh(mph): return round(mph * 1.60934, 1)

def print_enhanced_route_summary(df_route):
    print("\n" + "="*60); print("üìä ENHANCED ROUTE SUMMARY (MPH)"); print("="*60)
    total_points = len(df_route); total_distance_m = df_route['distance_to_next_m'].sum()
    total_distance_miles = total_distance_m / 1609.34
    print(f"Total Points: {total_points}")
    print(f"Total Distance: {total_distance_m/1000:.2f} km ({total_distance_miles:.2f} miles)")
    print(f"Elevation Range: {df_route['elev_m'].min():.1f} - {df_route['elev_m'].max():.1f} m")
    segment_summary = df_route.groupby(['segment_id', 'segment_type']).agg({'lat': 'count', 'distance_to_next_m': 'sum', 'speed_limit_mph': 'first', 'elev_m': ['min', 'max', 'mean']}).round(1)
    segment_summary.columns = ['points', 'length_m', 'speed_mph', 'elev_min', 'elev_max', 'elev_mean']
    segment_summary['length_miles'] = (segment_summary['length_m'] / 1609.34).round(3)
    print(f"\nSegments: {len(segment_summary)}")
    print("\nSegment Details (Sample):")
    print(segment_summary.head().to_string())
    speed_stats = df_route['speed_limit_mph'].value_counts().sort_index()
    print(f"\nSpeed Limit Distribution (MPH):")
    for speed, count in speed_stats.items():
        print(f"  {speed} mph: {count} points")
    segment_summary.to_csv("route_segments_detailed_mph.csv")
    print(f"\nüíæ Detailed segment analysis saved to: route_segments_detailed_mph.csv")

def get_route_from_api(start_coords, end_coords):
    print(f"üó∫Ô∏è  Getting route from {start_coords} to {end_coords}...")
    coordinates = f"{start_coords[1]},{start_coords[0]};{end_coords[1]},{end_coords[0]}"
    osrm_url = f"http://router.project-osrm.org/route/v1/driving/{coordinates}?overview=full&geometries=geojson"
    print(f"   API URL: {osrm_url}")
    try:
        response = requests.get(osrm_url, timeout=30)
        if response.status_code == 200:
            data = response.json();
            if 'routes' not in data or len(data['routes']) == 0:
                print("‚ùå No route found."); return None, None
            route_coords = data['routes'][0]['geometry']['coordinates']
            print(f"   ‚úÖ Route found: {len(route_coords)} points")
            route_data = [{'lon': coord[0], 'lat': coord[1]} for coord in route_coords]
            df_dense = pd.DataFrame(route_data)
            df_sparse = get_elevation_data(df_dense, num_points=200) # Use more points for a long route
            return df_dense, df_sparse
        else:
            print(f"‚ùå OSRM API error {response.status_code}: {response.text}"); return None, None
    except Exception as e:
        print(f"‚ùå API call failed: {e}"); return None, None
        
def get_user_coordinates():
    """
    Get start and end coordinates from user with better validation
    """
    print("üìç Enter route coordinates (latitude, longitude):")
    print("   Format: latitude,longitude")
    print("   Example: 51.5074,-0.1278 (London)")
    print("   Example: 55.9533,-3.1883 (Edinburgh)")
    print("   Example: 40.7128,-74.0060 (New York)")
    print()

    cities = {
        "1": ("London", (51.5074, -0.1278)),
        "2": ("Edinburgh", (55.9533, -3.1883)),
        "3": ("Manchester", (53.4808, -2.2426)),
        "4": ("New York", (40.7128, -74.0060)),
        "5": ("Los Angeles", (34.0522, -118.2437)),
        "6": ("Chicago", (41.8781, -87.6298)),
        "7": ("Custom", None)
    }

    print("Choose start city or enter custom coordinates:")
    for key, (name, coords) in cities.items():
        if coords:
            print(f"   {key}. {name}: {coords[0]:.4f}, {coords[1]:.4f}")
        else:
            print(f"   {key}. Custom coordinates")
    start_choice = input("\nSelect start (1-7): ").strip()

    if start_choice in cities and start_choice != "7":
        start_coords = cities[start_choice][1]
        print(f"   Start: {cities[start_choice][0]} {start_coords}")
    else:
        start_input = input("Enter START coordinates (lat,lon): ").strip()
        start_coords = parse_coordinates(start_input)
        if start_coords is None:
            return None, None

    print("\nChoose end city or enter custom coordinates:")
    for key, (name, coords) in cities.items():
        if coords:
            print(f"   {key}. {name}: {coords[0]:.4f}, {coords[1]:.4f}")
        else:
            print(f"   {key}. Custom coordinates")
    end_choice = input("\nSelect end (1-7): ").strip()

    if end_choice in cities and end_choice != "7":
        end_coords = cities[end_choice][1]
        print(f"   End: {cities[end_choice][0]} {end_coords}")
    else:
        end_input = input("Enter END coordinates (lat,lon): ").strip()
        end_coords = parse_coordinates(end_input)
        if end_coords is None:
            return None, None

    print(f"\n   Route: {start_coords} ‚Üí {end_coords}")
    return start_coords, end_coords

def parse_coordinates(coord_input):
    """
    Parse coordinate input with validation
    """
    try:
        if not coord_input:
            print("   Using London as default")
            return (51.5074, -0.1278)
        parts = [part.strip() for part in coord_input.split(',')]
        if len(parts) != 2:
            print("‚ùå Please use format: latitude,longitude")
            return None
        lat = float(parts[0]); lon = float(parts[1])
        if not (-90 <= lat <= 90):
            print("‚ùå Latitude must be between -90 and 90")
            return None
        if not (-180 <= lon <= 180):
            print("‚ùå Longitude must be between -180 and 180")
            return None
        return (lat, lon)
    except ValueError:
        print("‚ùå Please enter valid numbers for coordinates")
        return None

def create_fallback_route(start_coords, end_coords):
    print("   Creating fallback route...")
    num_points = 200
    start_lat, start_lon = start_coords
    end_lat, end_lon = end_coords
    lats = np.linspace(start_lat, end_lat, num_points)
    lons = np.linspace(start_lon, end_lon, num_points)
    t = np.linspace(0, np.pi, num_points)
    curve_strength = 0.1 * (end_lon - start_lon)
    lons = lons + curve_strength * np.sin(t)
    df_dense = pd.DataFrame({'lat': lats, 'lon': lons})
    df_sparse = get_elevation_data(df_dense, num_points=50)
    return df_dense, df_sparse
    
def create_route_file():
    """
    Main function from route_mapper.py, now interactive.
    """
    print("=" * 50)
    print("üöó 1. RUNNING INTERACTIVE ROUTE MAPPER")
    print("=" * 50)
    
    start_coords, end_coords = get_user_coordinates()
    if start_coords is None or end_coords is None:
        return False

    print("\n1. Fetching route data from APIs...")
    df_dense, df_sparse = get_route_from_api(start_coords, end_coords)
    
    if df_dense is None:
        print("‚ùå Failed to get route data. Using fallback sample route...")
        df_dense, df_sparse = create_fallback_route(start_coords, end_coords)
        if df_dense is None:
            print("‚ùå Fallback route failed. Cannot proceed.")
            return False

    print("2. Interpolating elevation data...")
    df_dense = interpolate_elevation(df_dense, df_sparse)
    print("3. Analyzing speed limits for each segment...")
    df_dense = calculate_point_distances(df_dense) # Calculate distances *first*
    df_dense = segment_route(df_dense)
    df_dense = assign_speed_limits_mpH(df_dense)
    df_dense = enhance_with_osm_speeds_mpH(df_dense)
    df_dense.to_csv(ROUTE_FILENAME, index=False)
    print_enhanced_route_summary(df_dense)
    print(f"\n‚úÖ Route mapping complete! File saved as '{ROUTE_FILENAME}'")
    return True

# --- 9. TOP SPEED FINDER (ROOT FINDING) ---

def _root_find_function(speed_mps, gear, slope_percent, final_drive_ratio, get_max_torque_at_rpm):
    """
    Calculates the Net Force on the vehicle.
    `fsolve` will try to find the `speed_mps` that makes this return 0.
    """
    if speed_mps < 0:
        return 1e9 # Disallow negative speeds
    
    # Calculate Tractive Force at WOT
    current_rpm = get_engine_rpm_from_speed(speed_mps, FIXED_GEAR_RATIOS_DICT[gear], final_drive_ratio)
    max_engine_torque = get_max_torque_at_rpm(current_rpm)
    gear_ratio = FIXED_GEAR_RATIOS_DICT[gear]
    total_reduction = gear_ratio * final_drive_ratio
    f_tractive = (max_engine_torque * total_reduction) / TIRE_RADIUS_M
    
    # Calculate Resistance Force
    f_resistance = calculate_resistance_forces(speed_mps, slope_percent)
    
    f_net = f_tractive - f_resistance
    return f_net

def find_top_speed(final_drive_ratio, gear, slope_percent, get_max_torque_func):
    """
    Wrapper for the fsolve root finder.
    """
    initial_guess_kmh = 200.0
    initial_guess_mps = initial_guess_kmh / 3.6
    
    try:
        top_speed_mps = fsolve(
            _root_find_function,
            initial_guess_mps,
            args=(gear, slope_percent, final_drive_ratio, get_max_torque_func)
        )[0]
        return top_speed_mps * 3.6 # Return km/h
    except Exception as e:
        print(f"  Error in root finding: {e}")
        return 0.0

# --- 10. MAIN EXECUTION ---
if __name__ == "__main__":
    try:
        # --- TASK 1: SETUP ENGINE ---
        print("--- TASK 1: SETTING UP ENGINE MODEL ---")
        setup_engine_model()
        
        # --- TASK 2: CREATE ROUTE FILE ---
        print("\n--- TASK 2: CREATING ROUTE FILE ---")
        if not create_route_file(): # This now calls the INTERACTIVE mapper
            raise SystemExit("\nüõë Halting execution. Route file could not be generated.")

        # --- TASK 3: PROCESS ROUTE FILE ---
        print("\n--- TASK 3: PRE-PROCESSING ROUTE FOR SIMULATION ---")
        if not preprocess_route():
             raise SystemExit("\nüõë Halting execution. Route file could not be processed.")
        
        # --- TASK 4: RUN OPTIMIZATION ---
        print("\n--- TASK 4: RUNNING HYBRID OPTIMIZATION ---")
        
        print("\nCalculating baseline fuel economy with initial ratio:")
        baseline_fuel = objective_function(BASE_FINAL_DRIVE_RATIO)
        
        if baseline_fuel == float('inf'):
             print("ERROR: Baseline simulation failed. Cannot proceed.")
             optimal_ratio = BASE_FINAL_DRIVE_RATIO # Use baseline as fallback
        else:
            print(f"Baseline Fuel Consumption: {baseline_fuel:.5f} Liters")
            print("\n--- STARTING 1D OPTIMIZATION ---")
            
            result = minimize_scalar(
                objective_function,
                bounds=(2.0, 4.5), # Search between these final drive ratios
                method='bounded',
                options={'xatol': 0.01} # Find answer within 0.01 ratio
            )
            
            print("\n--- OPTIMIZATION COMPLETE ---")
            
            if result.success:
                optimal_ratio = result.x
                final_fuel_cost = result.fun
                print(f"Baseline Ratio: {BASE_FINAL_DRIVE_RATIO:.3f} | Fuel: {baseline_fuel:.5f} L")
                print(f"Optimal Ratio:  {optimal_ratio:.3f} | Fuel: {final_fuel_cost:.5f} L")
                fuel_saved = baseline_fuel - final_fuel_cost
                percent_saved = (fuel_saved / baseline_fuel) * 100
                print(f"\nFuel Saved: {fuel_saved:.5f} L ({percent_saved:.2f}% improvement)")
            else:
                print("Optimization did not converge.")
                optimal_ratio = BASE_FINAL_DRIVE_RATIO # Use baseline as fallback

        # --- TASK 5: RUN TOP SPEED ANALYSIS (ROOT FINDING) ---
        print("\n--- TASK 5: RUNNING TOP SPEED ANALYSIS (ROOT FINDING) ---")
        
        print(f"\nTesting BASELINE Final Drive: {BASE_FINAL_DRIVE_RATIO:.3f}")
        top_speed_base = find_top_speed(BASE_FINAL_DRIVE_RATIO, 6, 0.0, get_max_torque)
        print(f"  > Top Speed (6th Gear, 0% Slope): {top_speed_base:.1f} km/h")
        
        print(f"\nTesting OPTIMAL Final Drive: {optimal_ratio:.3f}")
        top_speed_opt = find_top_speed(optimal_ratio, 6, 0.0, get_max_torque)
        print(f"  > Top Speed (6th Gear, 0% Slope): {top_speed_opt:.1f} km/h")

        print("\n--- ANALYSIS COMPLETE ---")

    except ImportError:
        print("\n--- ERROR ---")
        print("This script requires 'numpy', 'matplotlib', 'scipy', 'pandas', 'osmnx', 'geopandas', 'shapely', 'requests'.")
        print("Please install them by running:")
        print("pip install numpy matplotlib scipy pandas osmnx geopandas shapely requests")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
